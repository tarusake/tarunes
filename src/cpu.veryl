module cpu (
    clk   : input   clock                  ,
    rst   : input   reset                  ,
    cpubus: modport bus_if::<8, 16>::master,
) {
    // CPU Registers
    var reg_a : logic<8> ; // Accumulator
    var reg_x : logic<8> ; // X register
    var reg_y : logic<8> ; // Y register
    var reg_sp: logic<8> ; // Stack pointer
    var reg_pc: logic<16>; // Program counter
    var reg_p : logic<8> ; // Status Register

    // メモリレイテンシ待ちフラグ
    var mem_ready: logic;

    // opcode
    var opcode: logic<8>;

    // CPU Inst(only helloworld)
    enum opcode_t: logic<8> {
        // Register Control
        SEI = 8'h78,
        TXS = 8'h9A,
        INX = 8'hE8,
        DEY = 8'h88,
        // Load & Store
        LDA_IMM = 8'hA9,
        LDA_ABX = 8'hBD,
        LDX_IMM = 8'hA2,
        LDY_IMM = 8'hA0,
        STA_ABS = 8'h8D,
        // Branch
        BNE = 8'hD0,
        // JMP
        JMP_ABS = 8'h4C,
    }

    enum cpu_state_t {
        RESET0,
        RESET1,
        RESET2,
        RESET3,
        FETCH,
        DECODE,
        EXEC,
    }
    var state: cpu_state_t;

    function debug_cpu_state_str (
        state: input cpu_state_t,
    ) -> logic<64> {
        case (state) {
            cpu_state_t::RESET0: return "RESET0";
            cpu_state_t::RESET1: return "RESET1";
            cpu_state_t::RESET2: return "RESET2";
            cpu_state_t::RESET3: return "RESET3";
            cpu_state_t::FETCH : return "FETCH";
            cpu_state_t::DECODE: return "DECODE";
            cpu_state_t::EXEC  : return "EXEC";
        }
    }

    let state_debug: logic<64> = debug_cpu_state_str(state);

    always_ff {
        if_reset {
            state        = cpu_state_t::RESET0;
            cpubus.addr  = 0;
            cpubus.wen   = 0;
            cpubus.wdata = 0;
            reg_p        = 8'h24; // bit[5]=1,bit[2]=1
            reg_pc       = 16'h00;
        } else {
            case state {
                // 0xFFFCをセット
                cpu_state_t::RESET0: {
                    cpubus.addr = 16'hFFFC;
                    state       = cpu_state_t::RESET1;
                }
                // 0xFFFDをセット
                cpu_state_t::RESET1: {
                    cpubus.addr = 16'hFFFD;
                    state       = cpu_state_t::RESET2;
                }
                // RESET0でセットしたデータが反映されるので読む
                cpu_state_t::RESET2: {
                    cpubus.addr = 16'h0000;
                    reg_pc[7:0] = cpubus.rdata;
                    state       = cpu_state_t::RESET3;
                }
                // RESET1でセットしたデータが反映されるので読む
                cpu_state_t::RESET3: {
                    reg_pc[15:8] = cpubus.rdata;
                    state        = cpu_state_t::FETCH;
                }
                // PCを読み込む、データが返ってきたらDECODEステートへ
                cpu_state_t::FETCH: {
                    cpubus.addr = reg_pc;
                    cpubus.wen  = 0;
                    mem_ready   = 1;
                    // 1clk待つ
                    if (mem_ready) {
                        mem_ready = 0;
                        state     = cpu_state_t::DECODE;
                    }
                }
                cpu_state_t::DECODE: {
                    opcode = cpubus.rdata;

                    case (cpubus.rdata) {
                        // IRQフラグ無効
                        // ただし割り込み未実装のため現時点では意味はない
                        opcode_t::SEI: {
                            $display("[DECODE] PC=%04h OPCODE=SEI", reg_pc);
                            reg_p[2] = 1'b1;
                            state    = cpu_state_t::FETCH;
                            reg_pc   = reg_pc + 1;
                        }
                    }
                }
            }
        }
    }

}
