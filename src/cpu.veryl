module cpu (
    clk   : input   clock                  ,
    rst   : input   reset                  ,
    cpubus: modport bus_if::<8, 16>::master,
) {
    // CPU Registers
    var reg_a : logic<8> ; // Accumulator
    var reg_x : logic<8> ; // X register
    var reg_y : logic<8> ; // Y register
    var reg_sp: logic<8> ; // Stack pointer
    var reg_pc: logic<16>; // Program counter
    var reg_p : logic<8> ; // Status Register

    // メモリレイテンシ待ちフラグ
    var mem_ready: logic;

    // opcode
    var opcode: logic<8>;
    var op1   : logic<8>;

    // CPU Inst(only helloworld)
    enum opcode_t: logic<8> {
        // Register Control
        SEI = 8'h78,
        TXS = 8'h9A,
        INX = 8'hE8,
        DEY = 8'h88,
        // Load & Store
        LDA_IMM = 8'hA9,
        LDA_ABX = 8'hBD,
        LDX_IMM = 8'hA2,
        LDY_IMM = 8'hA0,
        STA_ABS = 8'h8D,
        // Branch
        BNE = 8'hD0,
        // JMP
        JMP_ABS = 8'h4C,
    }

    enum cpu_state_t {
        RESET0,
        RESET1,
        RESET2,
        RESET3,
        FETCH,
        DECODE,
        OP1,
        OP2,
        EXEC,
    }
    var state: cpu_state_t;

    function debug_cpu_state_str (
        state: input cpu_state_t,
    ) -> logic<64> {
        case (state) {
            cpu_state_t::RESET0: return "RESET0";
            cpu_state_t::RESET1: return "RESET1";
            cpu_state_t::RESET2: return "RESET2";
            cpu_state_t::RESET3: return "RESET3";
            cpu_state_t::FETCH : return "FETCH";
            cpu_state_t::DECODE: return "DECODE";
            cpu_state_t::OP1   : return "OP1";
            cpu_state_t::OP2   : return "OP2";
            cpu_state_t::EXEC  : return "EXEC";
        }
    }

    let state_debug: logic<64> = debug_cpu_state_str(state);

    always_ff {
        if_reset {
            state        = cpu_state_t::RESET0;
            cpubus.addr  = 0;
            cpubus.wen   = 0;
            cpubus.wdata = 0;
            reg_a        = 0;
            reg_x        = 0;
            reg_y        = 0;
            reg_sp       = 8'hFD;
            reg_p        = 8'h24; // bit[5]=1,bit[2]=1
            reg_pc       = 0;
            mem_ready    = 0;
            opcode       = 0;
        } else {
            case state {
                // 0xFFFCをセット
                cpu_state_t::RESET0: {
                    cpubus.addr = 16'hFFFC;
                    state       = cpu_state_t::RESET1;
                }
                // 0xFFFDをセット
                cpu_state_t::RESET1: {
                    cpubus.addr = 16'hFFFD;
                    state       = cpu_state_t::RESET2;
                }
                // RESET0でセットしたデータが反映されるので読む
                cpu_state_t::RESET2: {
                    cpubus.addr = 16'h0000;
                    reg_pc[7:0] = cpubus.rdata;
                    state       = cpu_state_t::RESET3;
                }
                // RESET1でセットしたデータが反映されるので読む
                cpu_state_t::RESET3: {
                    reg_pc[15:8] = cpubus.rdata;
                    state        = cpu_state_t::FETCH;
                }
                // PCを読み込む、データが返ってきたらDECODEステートへ
                cpu_state_t::FETCH: {
                    cpubus.addr = reg_pc;
                    cpubus.wen  = 0;
                    mem_ready   = 1;
                    // 1clk待つ
                    if (mem_ready) {
                        mem_ready = 0;
                        state     = cpu_state_t::DECODE;
                    }
                }
                cpu_state_t::DECODE: {
                    opcode = cpubus.rdata;

                    case (cpubus.rdata) {
                        // IRQフラグ無効
                        // ただし割り込み未実装のため現時点では意味はない
                        opcode_t::SEI: {
                            $display("[DECODE] PC=%04h OPCODE=SEI", reg_pc);
                            reg_p[2] = 1'b1;
                            state    = cpu_state_t::FETCH;
                            reg_pc   = reg_pc + 1;
                        }

                        opcode_t::TXS: {
                            $display("[DECODE] PC=%04h OPCODE=TXS", reg_pc);
                            reg_sp   = reg_x;
                            // TXSはフラグ更新しない
                            state  = cpu_state_t::FETCH;
                            reg_pc = reg_pc + 1;
                        }

                        opcode_t::INX: {
                            $display("[DECODE] PC=%04h OPCODE=INX", reg_pc);
                            let result  : logic<8> = reg_x + 1;
                            reg_x    = result;
                            reg_p[1] = (result == 0);
                            reg_p[7] = result[7];
                            state    = cpu_state_t::FETCH;
                            reg_pc   = reg_pc + 1;
                        }

                        opcode_t::DEY: {
                            $display("[DECODE] PC=%04h OPCODE=DEY", reg_pc);
                            let result  : logic<8> = reg_y - 1;
                            reg_y    = result;
                            reg_p[1] = (result == 0);
                            reg_p[7] = result[7];
                            state    = cpu_state_t::FETCH;
                            reg_pc   = reg_pc + 1;
                        }

                        // 即値命令
                        opcode_t::LDA_IMM,
                        opcode_t::LDX_IMM,
                        opcode_t::LDY_IMM : {
                            cpubus.addr = reg_pc + 1;
                            mem_ready   = 1;
                            if (mem_ready) {
                                mem_ready = 0;
                                state     = cpu_state_t::EXEC;
                            }
                        }

                        // それ以上の命令
                        opcode_t::STA_ABS,
                        opcode_t::LDA_ABX : {
                            cpubus.addr = reg_pc + 1;
                            mem_ready   = 1;
                            if (mem_ready) {
                                mem_ready = 0;
                                state     = cpu_state_t::OP1;
                            }
                        }

                        default: {
                            $display("[DECODE] Unknown Opcode : PC=%04h OPCODE=%02h", reg_pc, cpubus.rdata);
                        }
                    }
                }

                cpu_state_t::OP1: {
                    case (opcode) {
                        opcode_t::STA_ABS: {
                            op1         = cpubus.rdata;
                            cpubus.addr = reg_pc + 2;
                            mem_ready   = 1;
                            if (mem_ready) {
                                mem_ready = 0;
                                state     = cpu_state_t::EXEC;
                            }
                        }
                        opcode_t::LDA_ABX: {
                            op1         = cpubus.rdata;
                            cpubus.addr = reg_pc + 2;
                            mem_ready   = 1;
                            if (mem_ready) {
                                mem_ready = 0;
                                state     = cpu_state_t::OP2;
                            }
                        }
                    }
                }

                cpu_state_t::OP2: {
                    case (opcode) {
                        opcode_t::LDA_ABX: {
                            cpubus.addr = {cpubus.rdata, op1} + reg_x;
                            mem_ready   = 1;
                            if (mem_ready) {
                                mem_ready = 0;
                                state     = cpu_state_t::EXEC;
                            }
                        }
                    }
                }

                cpu_state_t::EXEC: {
                    case (opcode) {
                        opcode_t::LDA_IMM,
                        opcode_t::LDA_ABX : {
                            $display("[EXECUTE] PC=%04h LDA_XXX", reg_pc);
                            reg_a    = cpubus.rdata;
                            reg_a[1] = (cpubus.rdata == 0);
                            reg_a[7] = cpubus.rdata[7];
                            if (opcode == opcode_t::LDA_IMM) {
                                reg_pc = reg_pc + 2;
                            } else {
                                reg_pc = reg_pc + 3;
                            }
                            state = cpu_state_t::FETCH;
                        }
                        opcode_t::LDX_IMM: {
                            $display("[EXECUTE] PC=%04h LDX_IMM", reg_pc);
                            reg_x    = cpubus.rdata;
                            reg_p[1] = (cpubus.rdata == 0);
                            reg_p[7] = cpubus.rdata[7];
                            reg_pc   = reg_pc + 2;
                            state    = cpu_state_t::FETCH;
                        }
                        opcode_t::LDY_IMM: {
                            $display("[EXECUTE] PC=%04h LDY_IMM", reg_pc);
                            reg_y    = cpubus.rdata;
                            reg_p[1] = (cpubus.rdata == 0);
                            reg_p[7] = cpubus.rdata[7];
                            reg_pc   = reg_pc + 2;
                            state    = cpu_state_t::FETCH;
                        }
                        opcode_t::STA_ABS: {
                            $display    ("[OP2] PC=%04h OPCODE=STA_ABS", reg_pc);
                            cpubus.addr  = {cpubus.rdata, op1};
                            cpubus.wdata = reg_a;
                            cpubus.wen   = 1'b1;
                            reg_pc       = reg_pc + 3;
                            state        = cpu_state_t::FETCH;
                        }
                    }
                }
            }
        }
    }
}
